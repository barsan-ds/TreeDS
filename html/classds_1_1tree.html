<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>TreeDS: ds::tree&lt; T, Algorithm, Allocator &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">TreeDS
   &#160;<span id="projectnumber">1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>ds</b></li><li class="navelem"><a class="el" href="classds_1_1tree.html">tree</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classds_1_1tree-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">ds::tree&lt; T, Algorithm, Allocator &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>A binary tree data structure.  
 <a href="classds_1_1tree.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="tree_8hpp_source.html">tree.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for ds::tree&lt; T, Algorithm, Allocator &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classds_1_1tree.png" usemap="#ds::tree_3C_20T_2C_20Algorithm_2C_20Allocator_20_3E_map" alt=""/>
  <map id="ds::tree_3C_20T_2C_20Algorithm_2C_20Allocator_20_3E_map" name="ds::tree&lt; T, Algorithm, Allocator &gt;_map">
<area href="classds_1_1tree__base.html" title="Base class for tree. Do not use it directly. " alt="ds::tree_base&lt; T &gt;" shape="rect" coords="0,0,206,24"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ab1032344e4f8d7a086539f88c4864869"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab1032344e4f8d7a086539f88c4864869"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>pointer</b> = typename std::allocator_traits&lt; Allocator &gt;::pointer</td></tr>
<tr class="separator:ab1032344e4f8d7a086539f88c4864869"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb92fc6a216636a4fe9998b7feacefc1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abb92fc6a216636a4fe9998b7feacefc1"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>const_pointer</b> = typename std::allocator_traits&lt; Allocator &gt;::const_pointer</td></tr>
<tr class="separator:abb92fc6a216636a4fe9998b7feacefc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20e20f8d371c3b801afde04bcebba792"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a20e20f8d371c3b801afde04bcebba792"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>algorithm_type</b> = Algorithm</td></tr>
<tr class="separator:a20e20f8d371c3b801afde04bcebba792"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc849ed0bbd44378dcce258b9569ce2c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acc849ed0bbd44378dcce258b9569ce2c"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>allocator_type</b> = Allocator</td></tr>
<tr class="separator:acc849ed0bbd44378dcce258b9569ce2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2622aec2a37612302fc732bf284bd825"><td class="memTemplParams" colspan="2">template&lt;typename A &gt; </td></tr>
<tr class="memitem:a2622aec2a37612302fc732bf284bd825"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classds_1_1tree.html#a2622aec2a37612302fc732bf284bd825">iterator</a> = <a class="el" href="classds_1_1tree__iterator.html">tree_iterator</a>&lt; T, A, false &gt;</td></tr>
<tr class="separator:a2622aec2a37612302fc732bf284bd825"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab59e775388175382687b9b42c94261b0"><td class="memTemplParams" colspan="2">template&lt;typename A &gt; </td></tr>
<tr class="memitem:ab59e775388175382687b9b42c94261b0"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classds_1_1tree.html#ab59e775388175382687b9b42c94261b0">const_iterator</a> = <a class="el" href="classds_1_1tree__iterator.html">tree_iterator</a>&lt; T, A, true &gt;</td></tr>
<tr class="separator:ab59e775388175382687b9b42c94261b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6faabd63ae06bc2cd9bf30c35ccfd82c"><td class="memTemplParams" colspan="2">template&lt;typename A &gt; </td></tr>
<tr class="memitem:a6faabd63ae06bc2cd9bf30c35ccfd82c"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classds_1_1tree.html#a6faabd63ae06bc2cd9bf30c35ccfd82c">reverse_iterator</a> = std::reverse_iterator&lt; <a class="el" href="classds_1_1tree.html#a2622aec2a37612302fc732bf284bd825">iterator</a>&lt; A &gt;&gt;</td></tr>
<tr class="separator:a6faabd63ae06bc2cd9bf30c35ccfd82c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66edea253548a2c7908477aba9894d89"><td class="memTemplParams" colspan="2">template&lt;typename A &gt; </td></tr>
<tr class="memitem:a66edea253548a2c7908477aba9894d89"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classds_1_1tree.html#a66edea253548a2c7908477aba9894d89">const_reverse_iterator</a> = std::reverse_iterator&lt; <a class="el" href="classds_1_1tree.html#ab59e775388175382687b9b42c94261b0">const_iterator</a>&lt; A &gt;&gt;</td></tr>
<tr class="separator:a66edea253548a2c7908477aba9894d89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_types_classds_1_1tree__base"><td colspan="2" onclick="javascript:toggleInherit('pub_types_classds_1_1tree__base')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="classds_1_1tree__base.html">ds::tree_base&lt; T &gt;</a></td></tr>
<tr class="memitem:ae0c5f5979dd30d5bb66cec2c047cb62a inherit pub_types_classds_1_1tree__base"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae0c5f5979dd30d5bb66cec2c047cb62a"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classds_1_1tree__base.html#ae0c5f5979dd30d5bb66cec2c047cb62a">value_type</a> = T</td></tr>
<tr class="memdesc:ae0c5f5979dd30d5bb66cec2c047cb62a inherit pub_types_classds_1_1tree__base"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of elements. <br /></td></tr>
<tr class="separator:ae0c5f5979dd30d5bb66cec2c047cb62a inherit pub_types_classds_1_1tree__base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0c8cec9b58bda7a1fe35e540c4baa9e inherit pub_types_classds_1_1tree__base"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa0c8cec9b58bda7a1fe35e540c4baa9e"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classds_1_1tree__base.html#aa0c8cec9b58bda7a1fe35e540c4baa9e">reference</a> = <a class="el" href="classds_1_1tree__base.html#ae0c5f5979dd30d5bb66cec2c047cb62a">value_type</a> &amp;</td></tr>
<tr class="memdesc:aa0c8cec9b58bda7a1fe35e540c4baa9e inherit pub_types_classds_1_1tree__base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reference to element type. <br /></td></tr>
<tr class="separator:aa0c8cec9b58bda7a1fe35e540c4baa9e inherit pub_types_classds_1_1tree__base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8abaad92de13928aa86b0b41c7be0269 inherit pub_types_classds_1_1tree__base"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8abaad92de13928aa86b0b41c7be0269"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classds_1_1tree__base.html#a8abaad92de13928aa86b0b41c7be0269">const_reference</a> = const <a class="el" href="classds_1_1tree__base.html#ae0c5f5979dd30d5bb66cec2c047cb62a">value_type</a> &amp;</td></tr>
<tr class="memdesc:a8abaad92de13928aa86b0b41c7be0269 inherit pub_types_classds_1_1tree__base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reference to a constant element type. <br /></td></tr>
<tr class="separator:a8abaad92de13928aa86b0b41c7be0269 inherit pub_types_classds_1_1tree__base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b91f60cfcede962c0ce2af11f44cab2 inherit pub_types_classds_1_1tree__base"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9b91f60cfcede962c0ce2af11f44cab2"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classds_1_1tree__base.html#a9b91f60cfcede962c0ce2af11f44cab2">node_type</a> = <a class="el" href="classds_1_1node.html">node</a>&lt; T &gt;</td></tr>
<tr class="memdesc:a9b91f60cfcede962c0ce2af11f44cab2 inherit pub_types_classds_1_1tree__base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of node in this tree. <br /></td></tr>
<tr class="separator:a9b91f60cfcede962c0ce2af11f44cab2 inherit pub_types_classds_1_1tree__base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d18d43213a92bc031beec25cb28f59c inherit pub_types_classds_1_1tree__base"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2d18d43213a92bc031beec25cb28f59c"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classds_1_1tree__base.html#a2d18d43213a92bc031beec25cb28f59c">size_type</a> = std::size_t</td></tr>
<tr class="memdesc:a2d18d43213a92bc031beec25cb28f59c inherit pub_types_classds_1_1tree__base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type returned by <a class="el" href="classds_1_1tree__base.html#a9ec4df9231bfa76c3c38db425e0e545e">size()</a> method. <br /></td></tr>
<tr class="separator:a2d18d43213a92bc031beec25cb28f59c inherit pub_types_classds_1_1tree__base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1dad0adf4489ef2b3547e38ec81e7e42 inherit pub_types_classds_1_1tree__base"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1dad0adf4489ef2b3547e38ec81e7e42"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classds_1_1tree__base.html#a1dad0adf4489ef2b3547e38ec81e7e42">difference_type</a> = std::ptrdiff_t</td></tr>
<tr class="memdesc:a1dad0adf4489ef2b3547e38ec81e7e42 inherit pub_types_classds_1_1tree__base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type used for difference between iterators. <br /></td></tr>
<tr class="separator:a1dad0adf4489ef2b3547e38ec81e7e42 inherit pub_types_classds_1_1tree__base"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a1fdc2869d91d5bdbf3bf04dd6fcdaec5"><td class="memItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classds_1_1tree.html#a1fdc2869d91d5bdbf3bf04dd6fcdaec5">tree</a> ()=default</td></tr>
<tr class="separator:a1fdc2869d91d5bdbf3bf04dd6fcdaec5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e240211b7641303e98df592c4f4d838"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5e240211b7641303e98df592c4f4d838"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>tree</b> (const <a class="el" href="classds_1_1tree.html">tree</a> &amp;other)</td></tr>
<tr class="separator:a5e240211b7641303e98df592c4f4d838"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95fec3a97689f87f56eda6deac1ccc56"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a95fec3a97689f87f56eda6deac1ccc56"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>tree</b> (<a class="el" href="classds_1_1tree.html">tree</a> &amp;&amp;)=default</td></tr>
<tr class="separator:a95fec3a97689f87f56eda6deac1ccc56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb8dff00877087d0b786c88a60e06709"><td class="memTemplParams" colspan="2"><a class="anchor" id="acb8dff00877087d0b786c88a60e06709"></a>
template&lt;typename OtherAlg , typename OtherAlloc &gt; </td></tr>
<tr class="memitem:acb8dff00877087d0b786c88a60e06709"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><b>tree</b> (const <a class="el" href="classds_1_1tree.html">tree</a>&lt; T, OtherAlg, OtherAlloc &gt; &amp;other)</td></tr>
<tr class="separator:acb8dff00877087d0b786c88a60e06709"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d25a5f0342321c019c1234b835c3dd7"><td class="memTemplParams" colspan="2"><a class="anchor" id="a2d25a5f0342321c019c1234b835c3dd7"></a>
template&lt;typename OtherAlg , typename OtherAlloc &gt; </td></tr>
<tr class="memitem:a2d25a5f0342321c019c1234b835c3dd7"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><b>tree</b> (<a class="el" href="classds_1_1tree.html">tree</a>&lt; T, OtherAlg, OtherAlloc &gt; &amp;&amp;other)</td></tr>
<tr class="separator:a2d25a5f0342321c019c1234b835c3dd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9ef244f750b9627347b208b22ea4ee8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae9ef244f750b9627347b208b22ea4ee8"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>tree</b> (<a class="el" href="classds_1_1temporary__node.html">temporary_node</a>&lt; T &gt; &amp;&amp;root)</td></tr>
<tr class="separator:ae9ef244f750b9627347b208b22ea4ee8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3e064e789107b89c88f9d216c7c194d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af3e064e789107b89c88f9d216c7c194d"></a>
<a class="el" href="classds_1_1tree.html">tree</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="classds_1_1tree.html">tree</a> &amp;other)</td></tr>
<tr class="separator:af3e064e789107b89c88f9d216c7c194d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b85e7e72722c85c15c801c63d00c54f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2b85e7e72722c85c15c801c63d00c54f"></a>
<a class="el" href="classds_1_1tree.html">tree</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (<a class="el" href="classds_1_1tree.html">tree</a> &amp;&amp;)=default</td></tr>
<tr class="separator:a2b85e7e72722c85c15c801c63d00c54f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9883be1f020fe00d7fce890af0757e95"><td class="memTemplParams" colspan="2">template&lt;typename A  = Algorithm&gt; </td></tr>
<tr class="memitem:a9883be1f020fe00d7fce890af0757e95"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classds_1_1tree.html#a2622aec2a37612302fc732bf284bd825">iterator</a>&lt; A &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classds_1_1tree.html#a9883be1f020fe00d7fce890af0757e95">begin</a> ()</td></tr>
<tr class="memdesc:a9883be1f020fe00d7fce890af0757e95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the beginning.  <a href="#a9883be1f020fe00d7fce890af0757e95">More...</a><br /></td></tr>
<tr class="separator:a9883be1f020fe00d7fce890af0757e95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08228aecae75f12afda8f46895fe7b11"><td class="memTemplParams" colspan="2">template&lt;typename A  = Algorithm&gt; </td></tr>
<tr class="memitem:a08228aecae75f12afda8f46895fe7b11"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classds_1_1tree.html#ab59e775388175382687b9b42c94261b0">const_iterator</a>&lt; A &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classds_1_1tree.html#a08228aecae75f12afda8f46895fe7b11">begin</a> () const </td></tr>
<tr class="memdesc:a08228aecae75f12afda8f46895fe7b11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a constant iterator to the beginning.  <a href="#a08228aecae75f12afda8f46895fe7b11">More...</a><br /></td></tr>
<tr class="separator:a08228aecae75f12afda8f46895fe7b11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bc328035887fecd0923fbb284ac1420"><td class="memTemplParams" colspan="2">template&lt;typename A  = Algorithm&gt; </td></tr>
<tr class="memitem:a0bc328035887fecd0923fbb284ac1420"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classds_1_1tree.html#ab59e775388175382687b9b42c94261b0">const_iterator</a>&lt; A &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classds_1_1tree.html#a0bc328035887fecd0923fbb284ac1420">cbegin</a> () const </td></tr>
<tr class="memdesc:a0bc328035887fecd0923fbb284ac1420"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a constant iterator to the beginning.  <a href="#a0bc328035887fecd0923fbb284ac1420">More...</a><br /></td></tr>
<tr class="separator:a0bc328035887fecd0923fbb284ac1420"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4467f7fcb6ad85a4eb2001cc26835bd"><td class="memTemplParams" colspan="2">template&lt;typename A  = Algorithm&gt; </td></tr>
<tr class="memitem:aa4467f7fcb6ad85a4eb2001cc26835bd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classds_1_1tree.html#a2622aec2a37612302fc732bf284bd825">iterator</a>&lt; A &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classds_1_1tree.html#aa4467f7fcb6ad85a4eb2001cc26835bd">end</a> ()</td></tr>
<tr class="memdesc:aa4467f7fcb6ad85a4eb2001cc26835bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the end.  <a href="#aa4467f7fcb6ad85a4eb2001cc26835bd">More...</a><br /></td></tr>
<tr class="separator:aa4467f7fcb6ad85a4eb2001cc26835bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a477df6d607ba16afa41737b79d026155"><td class="memTemplParams" colspan="2"><a class="anchor" id="a477df6d607ba16afa41737b79d026155"></a>
template&lt;typename A  = Algorithm&gt; </td></tr>
<tr class="memitem:a477df6d607ba16afa41737b79d026155"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classds_1_1tree.html#ab59e775388175382687b9b42c94261b0">const_iterator</a>&lt; A &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>end</b> () const </td></tr>
<tr class="separator:a477df6d607ba16afa41737b79d026155"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fc3b520dd604f8695754153a2f9173d"><td class="memTemplParams" colspan="2"><a class="anchor" id="a0fc3b520dd604f8695754153a2f9173d"></a>
template&lt;typename A  = Algorithm&gt; </td></tr>
<tr class="memitem:a0fc3b520dd604f8695754153a2f9173d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classds_1_1tree.html#ab59e775388175382687b9b42c94261b0">const_iterator</a>&lt; A &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>cend</b> () const </td></tr>
<tr class="separator:a0fc3b520dd604f8695754153a2f9173d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62bd9bf9f78552b5789f52b09964fd4b"><td class="memTemplParams" colspan="2"><a class="anchor" id="a62bd9bf9f78552b5789f52b09964fd4b"></a>
template&lt;typename A  = Algorithm&gt; </td></tr>
<tr class="memitem:a62bd9bf9f78552b5789f52b09964fd4b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classds_1_1tree.html#a6faabd63ae06bc2cd9bf30c35ccfd82c">reverse_iterator</a>&lt; A &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>rbegin</b> ()</td></tr>
<tr class="separator:a62bd9bf9f78552b5789f52b09964fd4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b1d46a39e00c9743073dfafee9a5ffd"><td class="memTemplParams" colspan="2"><a class="anchor" id="a7b1d46a39e00c9743073dfafee9a5ffd"></a>
template&lt;typename A  = Algorithm&gt; </td></tr>
<tr class="memitem:a7b1d46a39e00c9743073dfafee9a5ffd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classds_1_1tree.html#a66edea253548a2c7908477aba9894d89">const_reverse_iterator</a>&lt; A &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>rbegin</b> () const </td></tr>
<tr class="separator:a7b1d46a39e00c9743073dfafee9a5ffd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a532ea2fdf3dc2362ab21b4e1ce4801b4"><td class="memTemplParams" colspan="2"><a class="anchor" id="a532ea2fdf3dc2362ab21b4e1ce4801b4"></a>
template&lt;typename A  = Algorithm&gt; </td></tr>
<tr class="memitem:a532ea2fdf3dc2362ab21b4e1ce4801b4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classds_1_1tree.html#a66edea253548a2c7908477aba9894d89">const_reverse_iterator</a>&lt; A &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>crbegin</b> () const </td></tr>
<tr class="separator:a532ea2fdf3dc2362ab21b4e1ce4801b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fea8fb2a0ddc8420953e1414c3bd388"><td class="memTemplParams" colspan="2"><a class="anchor" id="a8fea8fb2a0ddc8420953e1414c3bd388"></a>
template&lt;typename A  = Algorithm&gt; </td></tr>
<tr class="memitem:a8fea8fb2a0ddc8420953e1414c3bd388"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classds_1_1tree.html#a6faabd63ae06bc2cd9bf30c35ccfd82c">reverse_iterator</a>&lt; A &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>rend</b> ()</td></tr>
<tr class="separator:a8fea8fb2a0ddc8420953e1414c3bd388"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7afb862cd4dce2e3bf928fe13cdda27f"><td class="memTemplParams" colspan="2"><a class="anchor" id="a7afb862cd4dce2e3bf928fe13cdda27f"></a>
template&lt;typename A  = Algorithm&gt; </td></tr>
<tr class="memitem:a7afb862cd4dce2e3bf928fe13cdda27f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classds_1_1tree.html#a66edea253548a2c7908477aba9894d89">const_reverse_iterator</a>&lt; A &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>rend</b> () const </td></tr>
<tr class="separator:a7afb862cd4dce2e3bf928fe13cdda27f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8f060bd7928991f5e01f94275cb8d77"><td class="memTemplParams" colspan="2"><a class="anchor" id="ab8f060bd7928991f5e01f94275cb8d77"></a>
template&lt;typename A  = Algorithm&gt; </td></tr>
<tr class="memitem:ab8f060bd7928991f5e01f94275cb8d77"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classds_1_1tree.html#a66edea253548a2c7908477aba9894d89">const_reverse_iterator</a>&lt; A &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>crend</b> () const </td></tr>
<tr class="separator:ab8f060bd7928991f5e01f94275cb8d77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afaca6e81708a82ff5df07de16b7e1c7b"><td class="memTemplParams" colspan="2">template&lt;typename It &gt; </td></tr>
<tr class="memitem:afaca6e81708a82ff5df07de16b7e1c7b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classds_1_1tree.html#a2622aec2a37612302fc732bf284bd825">iterator</a>&lt; typename It::algorithm_type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classds_1_1tree.html#afaca6e81708a82ff5df07de16b7e1c7b">insert</a> (It position, <a class="el" href="classds_1_1temporary__node.html">temporary_node</a>&lt; T &gt; &amp;&amp;<a class="el" href="classds_1_1node.html">node</a>)</td></tr>
<tr class="separator:afaca6e81708a82ff5df07de16b7e1c7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af26485416f1c3a3ab03b9dfd7dce3340"><td class="memTemplParams" colspan="2">template&lt;typename It &gt; </td></tr>
<tr class="memitem:af26485416f1c3a3ab03b9dfd7dce3340"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classds_1_1tree.html#a2622aec2a37612302fc732bf284bd825">iterator</a>&lt; typename It::algorithm_type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classds_1_1tree.html#af26485416f1c3a3ab03b9dfd7dce3340">insert</a> (It position, <a class="el" href="classds_1_1tree__base.html#a8abaad92de13928aa86b0b41c7be0269">const_reference</a> value)</td></tr>
<tr class="separator:af26485416f1c3a3ab03b9dfd7dce3340"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e24dd0a3d12eacd370d731cdf8d4df0"><td class="memTemplParams" colspan="2">template&lt;typename It &gt; </td></tr>
<tr class="memitem:a1e24dd0a3d12eacd370d731cdf8d4df0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classds_1_1tree.html#a2622aec2a37612302fc732bf284bd825">iterator</a>&lt; typename It::algorithm_type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classds_1_1tree.html#a1e24dd0a3d12eacd370d731cdf8d4df0">insert</a> (It position, <a class="el" href="classds_1_1tree__base.html#ae0c5f5979dd30d5bb66cec2c047cb62a">value_type</a> &amp;&amp;value)</td></tr>
<tr class="separator:a1e24dd0a3d12eacd370d731cdf8d4df0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9fd11ae26be219b2672e468a5e8c9d8"><td class="memTemplParams" colspan="2"><a class="anchor" id="ae9fd11ae26be219b2672e468a5e8c9d8"></a>
template&lt;typename It , typename... Args&gt; </td></tr>
<tr class="memitem:ae9fd11ae26be219b2672e468a5e8c9d8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classds_1_1tree.html#a2622aec2a37612302fc732bf284bd825">iterator</a>&lt; typename It::algorithm_type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>emplace</b> (It position, Args &amp;&amp;...args)</td></tr>
<tr class="separator:ae9fd11ae26be219b2672e468a5e8c9d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classds_1_1tree__base"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classds_1_1tree__base')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classds_1_1tree__base.html">ds::tree_base&lt; T &gt;</a></td></tr>
<tr class="memitem:a35c2c9196cfef1a95cf0d1795ea9f730 inherit pub_methods_classds_1_1tree__base"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classds_1_1tree__base.html#a35c2c9196cfef1a95cf0d1795ea9f730">empty</a> () const </td></tr>
<tr class="memdesc:a35c2c9196cfef1a95cf0d1795ea9f730 inherit pub_methods_classds_1_1tree__base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether the container is empty.  <a href="#a35c2c9196cfef1a95cf0d1795ea9f730">More...</a><br /></td></tr>
<tr class="separator:a35c2c9196cfef1a95cf0d1795ea9f730 inherit pub_methods_classds_1_1tree__base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b80d41673c08773cd94012b399b0796 inherit pub_methods_classds_1_1tree__base"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classds_1_1tree__base.html#a1b80d41673c08773cd94012b399b0796">clear</a> ()</td></tr>
<tr class="memdesc:a1b80d41673c08773cd94012b399b0796 inherit pub_methods_classds_1_1tree__base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all elements from the tree.  <a href="#a1b80d41673c08773cd94012b399b0796">More...</a><br /></td></tr>
<tr class="separator:a1b80d41673c08773cd94012b399b0796 inherit pub_methods_classds_1_1tree__base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ec4df9231bfa76c3c38db425e0e545e inherit pub_methods_classds_1_1tree__base"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classds_1_1tree__base.html#a2d18d43213a92bc031beec25cb28f59c">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classds_1_1tree__base.html#a9ec4df9231bfa76c3c38db425e0e545e">size</a> () const </td></tr>
<tr class="memdesc:a9ec4df9231bfa76c3c38db425e0e545e inherit pub_methods_classds_1_1tree__base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of the nodes in this tree.  <a href="#a9ec4df9231bfa76c3c38db425e0e545e">More...</a><br /></td></tr>
<tr class="separator:a9ec4df9231bfa76c3c38db425e0e545e inherit pub_methods_classds_1_1tree__base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a807513fa3b0b4a8039f12fff948f20fc inherit pub_methods_classds_1_1tree__base"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classds_1_1tree__base.html#a2d18d43213a92bc031beec25cb28f59c">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classds_1_1tree__base.html#a807513fa3b0b4a8039f12fff948f20fc">max_size</a> () const </td></tr>
<tr class="memdesc:a807513fa3b0b4a8039f12fff948f20fc inherit pub_methods_classds_1_1tree__base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the maximum possible number of elements the tree can hold.  <a href="#a807513fa3b0b4a8039f12fff948f20fc">More...</a><br /></td></tr>
<tr class="separator:a807513fa3b0b4a8039f12fff948f20fc inherit pub_methods_classds_1_1tree__base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82d5edceb7b8bc4df85961d13003d39f inherit pub_methods_classds_1_1tree__base"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classds_1_1tree__base.html#a82d5edceb7b8bc4df85961d13003d39f">operator==</a> (const <a class="el" href="classds_1_1tree__base.html">tree_base</a> &amp;other)</td></tr>
<tr class="memdesc:a82d5edceb7b8bc4df85961d13003d39f inherit pub_methods_classds_1_1tree__base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a deep comparison of this tree with the other.  <a href="#a82d5edceb7b8bc4df85961d13003d39f">More...</a><br /></td></tr>
<tr class="separator:a82d5edceb7b8bc4df85961d13003d39f inherit pub_methods_classds_1_1tree__base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab91ec5bb2c40729545c7ce50e6dfd44a inherit pub_methods_classds_1_1tree__base"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classds_1_1tree__base.html#ab91ec5bb2c40729545c7ce50e6dfd44a">operator!=</a> (const <a class="el" href="classds_1_1tree__base.html">tree_base</a> &amp;other)</td></tr>
<tr class="separator:ab91ec5bb2c40729545c7ce50e6dfd44a inherit pub_methods_classds_1_1tree__base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08ab32dd985ff0f64b67da6ff4b0cbf9 inherit pub_methods_classds_1_1tree__base"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classds_1_1tree__base.html#a08ab32dd985ff0f64b67da6ff4b0cbf9">swap</a> (<a class="el" href="classds_1_1tree__base.html">tree_base</a>&lt; T &gt; &amp;other)</td></tr>
<tr class="memdesc:a08ab32dd985ff0f64b67da6ff4b0cbf9 inherit pub_methods_classds_1_1tree__base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps the contents of this tree with those of the other.  <a href="#a08ab32dd985ff0f64b67da6ff4b0cbf9">More...</a><br /></td></tr>
<tr class="separator:a08ab32dd985ff0f64b67da6ff4b0cbf9 inherit pub_methods_classds_1_1tree__base"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:af058143477c1baa77c9584f0fbaf0dfb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af058143477c1baa77c9584f0fbaf0dfb"></a>
static <a class="el" href="classds_1_1temporary__node.html">temporary_node</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>produce_node</b> (T value)</td></tr>
<tr class="separator:af058143477c1baa77c9584f0fbaf0dfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:ad7a47147f26926cd831723f2581162e0"><td class="memTemplParams" colspan="2"><a class="anchor" id="ad7a47147f26926cd831723f2581162e0"></a>
template&lt;typename , typename , typename &gt; </td></tr>
<tr class="memitem:ad7a47147f26926cd831723f2581162e0"><td class="memTemplItemLeft" align="right" valign="top">class&#160;</td><td class="memTemplItemRight" valign="bottom"><b>tree</b></td></tr>
<tr class="separator:ad7a47147f26926cd831723f2581162e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pro_methods_classds_1_1tree__base"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classds_1_1tree__base')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classds_1_1tree__base.html">ds::tree_base&lt; T &gt;</a></td></tr>
<tr class="memitem:abbed067ba6e2c6761c28591b60f19a3d inherit pro_methods_classds_1_1tree__base"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abbed067ba6e2c6761c28591b60f19a3d"></a>
constexpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classds_1_1tree__base.html#abbed067ba6e2c6761c28591b60f19a3d">tree_base</a> ()</td></tr>
<tr class="memdesc:abbed067ba6e2c6761c28591b60f19a3d inherit pro_methods_classds_1_1tree__base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an empty tree. <br /></td></tr>
<tr class="separator:abbed067ba6e2c6761c28591b60f19a3d inherit pro_methods_classds_1_1tree__base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86e950b12f9365a145f5bbd0c90c3175 inherit pro_methods_classds_1_1tree__base"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a86e950b12f9365a145f5bbd0c90c3175"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>tree_base</b> (const <a class="el" href="classds_1_1tree__base.html">tree_base</a> &amp;other)=delete</td></tr>
<tr class="separator:a86e950b12f9365a145f5bbd0c90c3175 inherit pro_methods_classds_1_1tree__base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f324183929101fcf2e9878bb7210dff inherit pro_methods_classds_1_1tree__base"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classds_1_1tree__base.html#a8f324183929101fcf2e9878bb7210dff">tree_base</a> (<a class="el" href="classds_1_1tree__base.html">tree_base</a> &amp;&amp;other)</td></tr>
<tr class="memdesc:a8f324183929101fcf2e9878bb7210dff inherit pro_methods_classds_1_1tree__base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a tree by moving the elements from another tree.  <a href="#a8f324183929101fcf2e9878bb7210dff">More...</a><br /></td></tr>
<tr class="separator:a8f324183929101fcf2e9878bb7210dff inherit pro_methods_classds_1_1tree__base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4c0fe27f9cebbd5c52b20cd99dc8ef0 inherit pro_methods_classds_1_1tree__base"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classds_1_1tree__base.html#ab4c0fe27f9cebbd5c52b20cd99dc8ef0">tree_base</a> (std::unique_ptr&lt; <a class="el" href="classds_1_1tree__base.html#a9b91f60cfcede962c0ce2af11f44cab2">node_type</a> &gt; root, <a class="el" href="classds_1_1tree__base.html#a2d18d43213a92bc031beec25cb28f59c">size_type</a> <a class="el" href="classds_1_1tree__base.html#a9ec4df9231bfa76c3c38db425e0e545e">size</a>)</td></tr>
<tr class="memdesc:ab4c0fe27f9cebbd5c52b20cd99dc8ef0 inherit pro_methods_classds_1_1tree__base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a tree by passing root and size information.  <a href="#ab4c0fe27f9cebbd5c52b20cd99dc8ef0">More...</a><br /></td></tr>
<tr class="separator:ab4c0fe27f9cebbd5c52b20cd99dc8ef0 inherit pro_methods_classds_1_1tree__base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9216427e3ef4a7059479f5cf7b5db0c1 inherit pro_methods_classds_1_1tree__base"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9216427e3ef4a7059479f5cf7b5db0c1"></a>
<a class="el" href="classds_1_1tree__base.html">tree_base</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="classds_1_1tree__base.html">tree_base</a> &amp;)=delete</td></tr>
<tr class="separator:a9216427e3ef4a7059479f5cf7b5db0c1 inherit pro_methods_classds_1_1tree__base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab588abb8213d1cf267b644a76645290f inherit pro_methods_classds_1_1tree__base"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classds_1_1tree__base.html">tree_base</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classds_1_1tree__base.html#ab588abb8213d1cf267b644a76645290f">operator=</a> (<a class="el" href="classds_1_1tree__base.html">tree_base</a> &amp;&amp;other)</td></tr>
<tr class="memdesc:ab588abb8213d1cf267b644a76645290f inherit pro_methods_classds_1_1tree__base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move assignment of the other tree to this tree.  <a href="#ab588abb8213d1cf267b644a76645290f">More...</a><br /></td></tr>
<tr class="separator:ab588abb8213d1cf267b644a76645290f inherit pro_methods_classds_1_1tree__base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_attribs_classds_1_1tree__base"><td colspan="2" onclick="javascript:toggleInherit('pro_attribs_classds_1_1tree__base')"><img src="closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="classds_1_1tree__base.html">ds::tree_base&lt; T &gt;</a></td></tr>
<tr class="memitem:a3df9452ececf2f10043ff930fe9d2d4c inherit pro_attribs_classds_1_1tree__base"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3df9452ececf2f10043ff930fe9d2d4c"></a>
std::unique_ptr&lt; <a class="el" href="classds_1_1tree__base.html#a9b91f60cfcede962c0ce2af11f44cab2">node_type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classds_1_1tree__base.html#a3df9452ececf2f10043ff930fe9d2d4c">_root</a></td></tr>
<tr class="memdesc:a3df9452ececf2f10043ff930fe9d2d4c inherit pro_attribs_classds_1_1tree__base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Owning pointer to the root node. <br /></td></tr>
<tr class="separator:a3df9452ececf2f10043ff930fe9d2d4c inherit pro_attribs_classds_1_1tree__base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e4c53bc09bebec06808d44aff17ac59 inherit pro_attribs_classds_1_1tree__base"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0e4c53bc09bebec06808d44aff17ac59"></a>
<a class="el" href="classds_1_1tree__base.html#a2d18d43213a92bc031beec25cb28f59c">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classds_1_1tree__base.html#a0e4c53bc09bebec06808d44aff17ac59">_size</a></td></tr>
<tr class="memdesc:a0e4c53bc09bebec06808d44aff17ac59 inherit pro_attribs_classds_1_1tree__base"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of nodes in the tree. <br /></td></tr>
<tr class="separator:a0e4c53bc09bebec06808d44aff17ac59 inherit pro_attribs_classds_1_1tree__base"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename T, typename Algorithm = pre_order, typename Allocator = std::allocator&lt;T&gt;&gt;<br />
class ds::tree&lt; T, Algorithm, Allocator &gt;</h3>

<p>A binary tree data structure. </p>
<p>A binary tree structured as a hierarchy of <a class="el" href="classds_1_1node.html">node</a>. Every node keeps an object of type T and can have a most two nodes as children. This class is compatible with STL containers. For example you can insert an element into the data structure by calling the usual:<br />
 </p><ul>
<li>
<a class="el" href="classds_1_1tree.html#af26485416f1c3a3ab03b9dfd7dce3340">insert(iterator, const T&amp;)</a> - if you want copy semantics </li>
<li>
<a class="el" href="classds_1_1tree.html#a1e24dd0a3d12eacd370d731cdf8d4df0">insert(iterator, T&amp;&amp;)</a> - if you want move semantics </li>
</ul>
<p>method and using an <a class="el" href="classds_1_1tree.html#a2622aec2a37612302fc732bf284bd825">iterator</a> as place indicator.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of element hold by the tree </td></tr>
    <tr><td class="paramname">Algorithm</td><td>default iterator algorithm used to traverse the tree in a range-based for loop </td></tr>
    <tr><td class="paramname">Allocator</td><td>allocator type used to allocate new nodes </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a class="anchor" id="ab59e775388175382687b9b42c94261b0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Algorithm = pre_order, typename Allocator = std::allocator&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename A &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classds_1_1tree.html">ds::tree</a>&lt; T, Algorithm, Allocator &gt;::<a class="el" href="classds_1_1tree.html#ab59e775388175382687b9b42c94261b0">const_iterator</a> =  <a class="el" href="classds_1_1tree__iterator.html">tree_iterator</a>&lt;T, A, true&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A bi-directional constant iterator used to traverse the tree. You can't modify the tree using this iterator. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">A</td><td>traversal algorithm used by the iterator </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a66edea253548a2c7908477aba9894d89"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Algorithm = pre_order, typename Allocator = std::allocator&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename A &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classds_1_1tree.html">ds::tree</a>&lt; T, Algorithm, Allocator &gt;::<a class="el" href="classds_1_1tree.html#a66edea253548a2c7908477aba9894d89">const_reverse_iterator</a> =  std::reverse_iterator&lt;<a class="el" href="classds_1_1tree.html#ab59e775388175382687b9b42c94261b0">const_iterator</a>&lt;A&gt;&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A bi-directional reverse iterator used to traverse the tree. You can't modify the tree using this iterator. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">A</td><td>traversal algorithm used by the iterator </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2622aec2a37612302fc732bf284bd825"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Algorithm = pre_order, typename Allocator = std::allocator&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename A &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classds_1_1tree.html">ds::tree</a>&lt; T, Algorithm, Allocator &gt;::<a class="el" href="classds_1_1tree.html#a2622aec2a37612302fc732bf284bd825">iterator</a> =  <a class="el" href="classds_1_1tree__iterator.html">tree_iterator</a>&lt;T, A, false&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A bi-directional iterator used to traverse the tree. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">A</td><td>traversal algorithm used by the iterator </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6faabd63ae06bc2cd9bf30c35ccfd82c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Algorithm = pre_order, typename Allocator = std::allocator&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename A &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classds_1_1tree.html">ds::tree</a>&lt; T, Algorithm, Allocator &gt;::<a class="el" href="classds_1_1tree.html#a6faabd63ae06bc2cd9bf30c35ccfd82c">reverse_iterator</a> =  std::reverse_iterator&lt;<a class="el" href="classds_1_1tree.html#a2622aec2a37612302fc732bf284bd825">iterator</a>&lt;A&gt;&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A bi-directional reverse iterator used to traverse the tree. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">A</td><td>traversal algorithm used by the iterator </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a1fdc2869d91d5bdbf3bf04dd6fcdaec5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Algorithm = pre_order, typename Allocator = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classds_1_1tree.html">ds::tree</a>&lt; T, Algorithm, Allocator &gt;::<a class="el" href="classds_1_1tree.html">tree</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Create an empty tree. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a9883be1f020fe00d7fce890af0757e95"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Algorithm = pre_order, typename Allocator = std::allocator&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename A  = Algorithm&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classds_1_1tree.html#a2622aec2a37612302fc732bf284bd825">iterator</a>&lt;A&gt; <a class="el" href="classds_1_1tree.html">ds::tree</a>&lt; T, Algorithm, Allocator &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the beginning. </p>
<p>The iterator will point to the first element of the container. Which one is the first depends on the algorithm used to traverse the tree. </p><dl class="section return"><dt>Returns</dt><dd>iterator to the first element </dd></dl>

</div>
</div>
<a class="anchor" id="a08228aecae75f12afda8f46895fe7b11"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Algorithm = pre_order, typename Allocator = std::allocator&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename A  = Algorithm&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classds_1_1tree.html#ab59e775388175382687b9b42c94261b0">const_iterator</a>&lt;A&gt; <a class="el" href="classds_1_1tree.html">ds::tree</a>&lt; T, Algorithm, Allocator &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a constant iterator to the beginning. </p>
<p>The iterator will point to the first element of the container. Which one is the first depends on the algorithm used to traverse the tree. Using this iterator you can't modify the container. </p><dl class="section return"><dt>Returns</dt><dd>constant iterator to the first element </dd></dl>

</div>
</div>
<a class="anchor" id="a0bc328035887fecd0923fbb284ac1420"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Algorithm = pre_order, typename Allocator = std::allocator&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename A  = Algorithm&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classds_1_1tree.html#ab59e775388175382687b9b42c94261b0">const_iterator</a>&lt;A&gt; <a class="el" href="classds_1_1tree.html">ds::tree</a>&lt; T, Algorithm, Allocator &gt;::cbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a constant iterator to the beginning. </p>
<p>The iterator will point to the first element of the container. Which one is the first depends on the algorithm used to traverse the tree. Using this iterator you can't modify the container. </p><dl class="section return"><dt>Returns</dt><dd>constant iterator to the first element </dd></dl>

</div>
</div>
<a class="anchor" id="aa4467f7fcb6ad85a4eb2001cc26835bd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Algorithm = pre_order, typename Allocator = std::allocator&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename A  = Algorithm&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classds_1_1tree.html#a2622aec2a37612302fc732bf284bd825">iterator</a>&lt;A&gt; <a class="el" href="classds_1_1tree.html">ds::tree</a>&lt; T, Algorithm, Allocator &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the end. </p>
<p>The iterator will point one step after the last element of the container. Which one is the last depends on the algorithm used to traverse the tree. It's perfectly legitimate to decrement this iterator to obtain the last element. </p><dl class="section return"><dt>Returns</dt><dd>iterator the element following the last element </dd></dl>

</div>
</div>
<a class="anchor" id="afaca6e81708a82ff5df07de16b7e1c7b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Algorithm = pre_order, typename Allocator = std::allocator&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename It &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classds_1_1tree.html#a2622aec2a37612302fc732bf284bd825">iterator</a>&lt;typename It::algorithm_type&gt; <a class="el" href="classds_1_1tree.html">ds::tree</a>&lt; T, Algorithm, Allocator &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">It&#160;</td>
          <td class="paramname"><em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classds_1_1temporary__node.html">temporary_node</a>&lt; T &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>node</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Insert an element at the specified position by replacing the existent node. This will use the copy semantics. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">position</td><td>where to insert the element </td></tr>
    <tr><td class="paramname">node</td><td>an r-value reference to a <a class="el" href="classds_1_1temporary__node.html">temporary_node</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an iterator that points to the inserted element </dd></dl>

</div>
</div>
<a class="anchor" id="af26485416f1c3a3ab03b9dfd7dce3340"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Algorithm = pre_order, typename Allocator = std::allocator&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename It &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classds_1_1tree.html#a2622aec2a37612302fc732bf284bd825">iterator</a>&lt;typename It::algorithm_type&gt; <a class="el" href="classds_1_1tree.html">ds::tree</a>&lt; T, Algorithm, Allocator &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">It&#160;</td>
          <td class="paramname"><em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classds_1_1tree__base.html#a8abaad92de13928aa86b0b41c7be0269">const_reference</a>&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Insert an element at the specified position by replacing the existent node. This will use the copy semantics. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">position</td><td>where to insert the element </td></tr>
    <tr><td class="paramname">value</td><td>to insert in the tree, that will be copied </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an iterator that points to the inserted element </dd></dl>

</div>
</div>
<a class="anchor" id="a1e24dd0a3d12eacd370d731cdf8d4df0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Algorithm = pre_order, typename Allocator = std::allocator&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename It &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classds_1_1tree.html#a2622aec2a37612302fc732bf284bd825">iterator</a>&lt;typename It::algorithm_type&gt; <a class="el" href="classds_1_1tree.html">ds::tree</a>&lt; T, Algorithm, Allocator &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">It&#160;</td>
          <td class="paramname"><em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classds_1_1tree__base.html#ae0c5f5979dd30d5bb66cec2c047cb62a">value_type</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Insert an element at the specified position by replacing the existent node. This will use the move semantics. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">position</td><td>where to insert the element </td></tr>
    <tr><td class="paramname">value</td><td>to insert in the tree, that will be copied </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an iterator that points to the inserted element </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/TreeDS/<a class="el" href="tree_8hpp_source.html">tree.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
