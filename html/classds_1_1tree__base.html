<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>TreeDS: ds::tree_base&lt; T &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">TreeDS
   &#160;<span id="projectnumber">1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>ds</b></li><li class="navelem"><a class="el" href="classds_1_1tree__base.html">tree_base</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classds_1_1tree__base-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">ds::tree_base&lt; T &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Base class for <a class="el" href="classds_1_1tree.html">tree</a>. Do not use it directly.  
 <a href="classds_1_1tree__base.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="tree__base_8hpp_source.html">tree_base.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for ds::tree_base&lt; T &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classds_1_1tree__base.png" usemap="#ds::tree_5Fbase_3C_20T_20_3E_map" alt=""/>
  <map id="ds::tree_5Fbase_3C_20T_20_3E_map" name="ds::tree_base&lt; T &gt;_map">
<area href="classds_1_1tree.html" title="A binary tree data structure. " alt="ds::tree&lt; T, Algorithm, Allocator &gt;" shape="rect" coords="0,56,206,80"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ae0c5f5979dd30d5bb66cec2c047cb62a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae0c5f5979dd30d5bb66cec2c047cb62a"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classds_1_1tree__base.html#ae0c5f5979dd30d5bb66cec2c047cb62a">value_type</a> = T</td></tr>
<tr class="memdesc:ae0c5f5979dd30d5bb66cec2c047cb62a"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of elements. <br /></td></tr>
<tr class="separator:ae0c5f5979dd30d5bb66cec2c047cb62a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0c8cec9b58bda7a1fe35e540c4baa9e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa0c8cec9b58bda7a1fe35e540c4baa9e"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classds_1_1tree__base.html#aa0c8cec9b58bda7a1fe35e540c4baa9e">reference</a> = <a class="el" href="classds_1_1tree__base.html#ae0c5f5979dd30d5bb66cec2c047cb62a">value_type</a> &amp;</td></tr>
<tr class="memdesc:aa0c8cec9b58bda7a1fe35e540c4baa9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reference to element type. <br /></td></tr>
<tr class="separator:aa0c8cec9b58bda7a1fe35e540c4baa9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8abaad92de13928aa86b0b41c7be0269"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8abaad92de13928aa86b0b41c7be0269"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classds_1_1tree__base.html#a8abaad92de13928aa86b0b41c7be0269">const_reference</a> = const <a class="el" href="classds_1_1tree__base.html#ae0c5f5979dd30d5bb66cec2c047cb62a">value_type</a> &amp;</td></tr>
<tr class="memdesc:a8abaad92de13928aa86b0b41c7be0269"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reference to a constant element type. <br /></td></tr>
<tr class="separator:a8abaad92de13928aa86b0b41c7be0269"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b91f60cfcede962c0ce2af11f44cab2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9b91f60cfcede962c0ce2af11f44cab2"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classds_1_1tree__base.html#a9b91f60cfcede962c0ce2af11f44cab2">node_type</a> = <a class="el" href="classds_1_1node.html">node</a>&lt; T &gt;</td></tr>
<tr class="memdesc:a9b91f60cfcede962c0ce2af11f44cab2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of node in this tree. <br /></td></tr>
<tr class="separator:a9b91f60cfcede962c0ce2af11f44cab2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d18d43213a92bc031beec25cb28f59c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2d18d43213a92bc031beec25cb28f59c"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classds_1_1tree__base.html#a2d18d43213a92bc031beec25cb28f59c">size_type</a> = std::size_t</td></tr>
<tr class="memdesc:a2d18d43213a92bc031beec25cb28f59c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type returned by <a class="el" href="classds_1_1tree__base.html#a9ec4df9231bfa76c3c38db425e0e545e">size()</a> method. <br /></td></tr>
<tr class="separator:a2d18d43213a92bc031beec25cb28f59c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1dad0adf4489ef2b3547e38ec81e7e42"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1dad0adf4489ef2b3547e38ec81e7e42"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classds_1_1tree__base.html#a1dad0adf4489ef2b3547e38ec81e7e42">difference_type</a> = std::ptrdiff_t</td></tr>
<tr class="memdesc:a1dad0adf4489ef2b3547e38ec81e7e42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type used for difference between iterators. <br /></td></tr>
<tr class="separator:a1dad0adf4489ef2b3547e38ec81e7e42"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a35c2c9196cfef1a95cf0d1795ea9f730"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classds_1_1tree__base.html#a35c2c9196cfef1a95cf0d1795ea9f730">empty</a> () const </td></tr>
<tr class="memdesc:a35c2c9196cfef1a95cf0d1795ea9f730"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether the container is empty.  <a href="#a35c2c9196cfef1a95cf0d1795ea9f730">More...</a><br /></td></tr>
<tr class="separator:a35c2c9196cfef1a95cf0d1795ea9f730"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b80d41673c08773cd94012b399b0796"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classds_1_1tree__base.html#a1b80d41673c08773cd94012b399b0796">clear</a> ()</td></tr>
<tr class="memdesc:a1b80d41673c08773cd94012b399b0796"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all elements from the tree.  <a href="#a1b80d41673c08773cd94012b399b0796">More...</a><br /></td></tr>
<tr class="separator:a1b80d41673c08773cd94012b399b0796"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ec4df9231bfa76c3c38db425e0e545e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classds_1_1tree__base.html#a2d18d43213a92bc031beec25cb28f59c">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classds_1_1tree__base.html#a9ec4df9231bfa76c3c38db425e0e545e">size</a> () const </td></tr>
<tr class="memdesc:a9ec4df9231bfa76c3c38db425e0e545e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of the nodes in this tree.  <a href="#a9ec4df9231bfa76c3c38db425e0e545e">More...</a><br /></td></tr>
<tr class="separator:a9ec4df9231bfa76c3c38db425e0e545e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a807513fa3b0b4a8039f12fff948f20fc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classds_1_1tree__base.html#a2d18d43213a92bc031beec25cb28f59c">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classds_1_1tree__base.html#a807513fa3b0b4a8039f12fff948f20fc">max_size</a> () const </td></tr>
<tr class="memdesc:a807513fa3b0b4a8039f12fff948f20fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the maximum possible number of elements the tree can hold.  <a href="#a807513fa3b0b4a8039f12fff948f20fc">More...</a><br /></td></tr>
<tr class="separator:a807513fa3b0b4a8039f12fff948f20fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82d5edceb7b8bc4df85961d13003d39f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classds_1_1tree__base.html#a82d5edceb7b8bc4df85961d13003d39f">operator==</a> (const <a class="el" href="classds_1_1tree__base.html">tree_base</a> &amp;other)</td></tr>
<tr class="memdesc:a82d5edceb7b8bc4df85961d13003d39f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a deep comparison of this tree with the other.  <a href="#a82d5edceb7b8bc4df85961d13003d39f">More...</a><br /></td></tr>
<tr class="separator:a82d5edceb7b8bc4df85961d13003d39f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab91ec5bb2c40729545c7ce50e6dfd44a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classds_1_1tree__base.html#ab91ec5bb2c40729545c7ce50e6dfd44a">operator!=</a> (const <a class="el" href="classds_1_1tree__base.html">tree_base</a> &amp;other)</td></tr>
<tr class="separator:ab91ec5bb2c40729545c7ce50e6dfd44a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08ab32dd985ff0f64b67da6ff4b0cbf9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classds_1_1tree__base.html#a08ab32dd985ff0f64b67da6ff4b0cbf9">swap</a> (<a class="el" href="classds_1_1tree__base.html">tree_base</a>&lt; T &gt; &amp;other)</td></tr>
<tr class="memdesc:a08ab32dd985ff0f64b67da6ff4b0cbf9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps the contents of this tree with those of the other.  <a href="#a08ab32dd985ff0f64b67da6ff4b0cbf9">More...</a><br /></td></tr>
<tr class="separator:a08ab32dd985ff0f64b67da6ff4b0cbf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:abbed067ba6e2c6761c28591b60f19a3d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abbed067ba6e2c6761c28591b60f19a3d"></a>
constexpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classds_1_1tree__base.html#abbed067ba6e2c6761c28591b60f19a3d">tree_base</a> ()</td></tr>
<tr class="memdesc:abbed067ba6e2c6761c28591b60f19a3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an empty tree. <br /></td></tr>
<tr class="separator:abbed067ba6e2c6761c28591b60f19a3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86e950b12f9365a145f5bbd0c90c3175"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a86e950b12f9365a145f5bbd0c90c3175"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>tree_base</b> (const <a class="el" href="classds_1_1tree__base.html">tree_base</a> &amp;other)=delete</td></tr>
<tr class="separator:a86e950b12f9365a145f5bbd0c90c3175"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f324183929101fcf2e9878bb7210dff"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classds_1_1tree__base.html#a8f324183929101fcf2e9878bb7210dff">tree_base</a> (<a class="el" href="classds_1_1tree__base.html">tree_base</a> &amp;&amp;other)</td></tr>
<tr class="memdesc:a8f324183929101fcf2e9878bb7210dff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a tree by moving the elements from another tree.  <a href="#a8f324183929101fcf2e9878bb7210dff">More...</a><br /></td></tr>
<tr class="separator:a8f324183929101fcf2e9878bb7210dff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4c0fe27f9cebbd5c52b20cd99dc8ef0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classds_1_1tree__base.html#ab4c0fe27f9cebbd5c52b20cd99dc8ef0">tree_base</a> (std::unique_ptr&lt; <a class="el" href="classds_1_1tree__base.html#a9b91f60cfcede962c0ce2af11f44cab2">node_type</a> &gt; root, <a class="el" href="classds_1_1tree__base.html#a2d18d43213a92bc031beec25cb28f59c">size_type</a> <a class="el" href="classds_1_1tree__base.html#a9ec4df9231bfa76c3c38db425e0e545e">size</a>)</td></tr>
<tr class="memdesc:ab4c0fe27f9cebbd5c52b20cd99dc8ef0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a tree by passing root and size information.  <a href="#ab4c0fe27f9cebbd5c52b20cd99dc8ef0">More...</a><br /></td></tr>
<tr class="separator:ab4c0fe27f9cebbd5c52b20cd99dc8ef0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9216427e3ef4a7059479f5cf7b5db0c1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9216427e3ef4a7059479f5cf7b5db0c1"></a>
<a class="el" href="classds_1_1tree__base.html">tree_base</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="classds_1_1tree__base.html">tree_base</a> &amp;)=delete</td></tr>
<tr class="separator:a9216427e3ef4a7059479f5cf7b5db0c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab588abb8213d1cf267b644a76645290f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classds_1_1tree__base.html">tree_base</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classds_1_1tree__base.html#ab588abb8213d1cf267b644a76645290f">operator=</a> (<a class="el" href="classds_1_1tree__base.html">tree_base</a> &amp;&amp;other)</td></tr>
<tr class="memdesc:ab588abb8213d1cf267b644a76645290f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move assignment of the other tree to this tree.  <a href="#ab588abb8213d1cf267b644a76645290f">More...</a><br /></td></tr>
<tr class="separator:ab588abb8213d1cf267b644a76645290f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a3df9452ececf2f10043ff930fe9d2d4c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3df9452ececf2f10043ff930fe9d2d4c"></a>
std::unique_ptr&lt; <a class="el" href="classds_1_1tree__base.html#a9b91f60cfcede962c0ce2af11f44cab2">node_type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classds_1_1tree__base.html#a3df9452ececf2f10043ff930fe9d2d4c">_root</a></td></tr>
<tr class="memdesc:a3df9452ececf2f10043ff930fe9d2d4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Owning pointer to the root node. <br /></td></tr>
<tr class="separator:a3df9452ececf2f10043ff930fe9d2d4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e4c53bc09bebec06808d44aff17ac59"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0e4c53bc09bebec06808d44aff17ac59"></a>
<a class="el" href="classds_1_1tree__base.html#a2d18d43213a92bc031beec25cb28f59c">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classds_1_1tree__base.html#a0e4c53bc09bebec06808d44aff17ac59">_size</a></td></tr>
<tr class="memdesc:a0e4c53bc09bebec06808d44aff17ac59"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of nodes in the tree. <br /></td></tr>
<tr class="separator:a0e4c53bc09bebec06808d44aff17ac59"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a3eb98ccc605b2d7c29a9caa36be1fa69"><td class="memTemplParams" colspan="2"><a class="anchor" id="a3eb98ccc605b2d7c29a9caa36be1fa69"></a>
template&lt;typename , typename , bool &gt; </td></tr>
<tr class="memitem:a3eb98ccc605b2d7c29a9caa36be1fa69"><td class="memTemplItemLeft" align="right" valign="top">class&#160;</td><td class="memTemplItemRight" valign="bottom"><b>tree_iterator</b></td></tr>
<tr class="separator:a3eb98ccc605b2d7c29a9caa36be1fa69"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename T&gt;<br />
class ds::tree_base&lt; T &gt;</h3>

<p>Base class for <a class="el" href="classds_1_1tree.html">tree</a>. Do not use it directly. </p>
<p>The purpose of this class is to have a type that depends only on the T template parameter. As iterators need to keep a pointer to this class (to obtain the <a class="el" href="classds_1_1tree__base.html#a3df9452ececf2f10043ff930fe9d2d4c">root node</a>), all the iterators of this container can depend only on the value type (T) (this is known as scary iterator) and. Doing so you can assign iterators of different container type (but with the same value_type, e.g.: different allocator) to each other. REMEMBER: this is not required by the standard: you shouldn't rely on this behavior for other STL containers. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a8f324183929101fcf2e9878bb7210dff"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classds_1_1tree__base.html">ds::tree_base</a>&lt; T &gt;::<a class="el" href="classds_1_1tree__base.html">tree_base</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classds_1_1tree__base.html">tree_base</a>&lt; T &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a tree by moving the elements from another tree. </p>
<p>The moved tree will have no nodes after this operator and its size will be 0. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the tree to be moved into this tree. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab4c0fe27f9cebbd5c52b20cd99dc8ef0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classds_1_1tree__base.html">ds::tree_base</a>&lt; T &gt;::<a class="el" href="classds_1_1tree__base.html">tree_base</a> </td>
          <td>(</td>
          <td class="paramtype">std::unique_ptr&lt; <a class="el" href="classds_1_1tree__base.html#a9b91f60cfcede962c0ce2af11f44cab2">node_type</a> &gt;&#160;</td>
          <td class="paramname"><em>root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classds_1_1tree__base.html#a2d18d43213a92bc031beec25cb28f59c">size_type</a>&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a tree by passing root and size information. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">root</td><td>an owning pointer to the root node </td></tr>
    <tr><td class="paramname">size</td><td>the size of the tree </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a1b80d41673c08773cd94012b399b0796"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classds_1_1tree__base.html">ds::tree_base</a>&lt; T &gt;::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes all elements from the tree. </p>
<p>Invalidates any references, pointers, or iterators referring to contained elements. Any past-the-last element iterator (<a class="el" href="classds_1_1tree.html#aa4467f7fcb6ad85a4eb2001cc26835bd">end()</a>) remains valid. </p>

</div>
</div>
<a class="anchor" id="a35c2c9196cfef1a95cf0d1795ea9f730"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classds_1_1tree__base.html">ds::tree_base</a>&lt; T &gt;::empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks whether the container is empty. </p>
<p>If a tree is empty then: </p><ul>
<li>
It doesn't have a root. </li>
<li>
It has a <a class="el" href="classds_1_1tree__base.html#a9ec4df9231bfa76c3c38db425e0e545e">size()</a> of 0. </li>
<li>
<a class="el" href="classds_1_1tree.html#a9883be1f020fe00d7fce890af0757e95">begin()</a> == <a class="el" href="classds_1_1tree.html#aa4467f7fcb6ad85a4eb2001cc26835bd">end()</a>. </li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>true if the tree is empty </dd></dl>

</div>
</div>
<a class="anchor" id="a807513fa3b0b4a8039f12fff948f20fc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classds_1_1tree__base.html#a2d18d43213a92bc031beec25cb28f59c">size_type</a> <a class="el" href="classds_1_1tree__base.html">ds::tree_base</a>&lt; T &gt;::max_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the maximum possible number of elements the tree can hold. </p>
<p>Please note that this is not the real value because the size of the tree will be more likely limited by the amount of free memory. You never want to use this method, it is stupid, it exists just to say that this library is stl-like. </p><dl class="section return"><dt>Returns</dt><dd>maximum possible number of elements </dd></dl>

</div>
</div>
<a class="anchor" id="ab91ec5bb2c40729545c7ce50e6dfd44a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classds_1_1tree__base.html">ds::tree_base</a>&lt; T &gt;::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classds_1_1tree__base.html">tree_base</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Performs a deep comparison of this tree with the other. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the tree to compare with </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the trees are <b>not</b> lexicographically equal </dd></dl>

</div>
</div>
<a class="anchor" id="ab588abb8213d1cf267b644a76645290f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classds_1_1tree__base.html">tree_base</a>&amp; <a class="el" href="classds_1_1tree__base.html">ds::tree_base</a>&lt; T &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classds_1_1tree__base.html">tree_base</a>&lt; T &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move assignment of the other tree to this tree. </p>
<p>The moved tree will have no nodes after this operator and its size will be 0. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the tree to be moved into this tree. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>this tree reference </dd></dl>

</div>
</div>
<a class="anchor" id="a82d5edceb7b8bc4df85961d13003d39f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classds_1_1tree__base.html">ds::tree_base</a>&lt; T &gt;::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classds_1_1tree__base.html">tree_base</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a deep comparison of this tree with the other. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the tree to compare with </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the trees are lexicographically equal </dd></dl>

</div>
</div>
<a class="anchor" id="a9ec4df9231bfa76c3c38db425e0e545e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classds_1_1tree__base.html#a2d18d43213a92bc031beec25cb28f59c">size_type</a> <a class="el" href="classds_1_1tree__base.html">ds::tree_base</a>&lt; T &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of the nodes in this tree. </p>
<dl class="section return"><dt>Returns</dt><dd>the number of nodes </dd></dl>

</div>
</div>
<a class="anchor" id="a08ab32dd985ff0f64b67da6ff4b0cbf9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classds_1_1tree__base.html">ds::tree_base</a>&lt; T &gt;::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classds_1_1tree__base.html">tree_base</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swaps the contents of this tree with those of the other. </p>
<p>After this method will be called, this tree will have the root and size of the other tree while the other tree will have root and size of this tree. All references to elements remain valid. Iterators however will not. Do not use iterator after you swapped trees. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the tree to swap with </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/TreeDS/<a class="el" href="tree__base_8hpp_source.html">tree_base.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
